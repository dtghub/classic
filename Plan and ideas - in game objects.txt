Currently a separate document from the main plan and ideas document, to help plan and work out the implementation details for the command parser; in particular how to handle the in-game items such as things that the player can pick up and / or interact with.

Types of objects we might need to deal with;

  - Physical items like a lamp, a box of matches etc which can be picked up and dropped and manipulated.
  - Items which are actually properties of a room such as door locks, pictures hanging on walls, (darkness?).
  - Properties which are partially or completely room independent such as day/night (darkness), hunger and other decrement counters (e.g. the lamp needs filled with oil)?



Ways to interact with objects;

  - know information; examine an item 'examine paper' "This is a ordinary looking piece of notepaper. It has a note scribbled on it in blue ink" (also display information e.g. 'read note' or do we make note a synonym which gets tokenised to 'Npaper'?).
  - take action; set a property flag (e.g. lamp is lit - or do we just swap a lamp for a lit lamp i.e. they are two different objects?)
  - move item; set the location of an item (room number, ?room number but invisible?, in your inventory, other special locations such as in a drawer).


          - 'blank' values need to have a default response - populate the blank values for the initial early stage, but implement some form of prototype inheritance


    - So now we need a 'protype' database table(s) which has a set of default commands for each inventory
      - maybe allow different items to inherit from other than the default.




A crude command parser has been implemented and the code tidied up a bit, including moving some code into small dedicated-purpose functions to remove duplication and help readability.
  - It's very clear that the syntax as implemented works but is not human friendly, and the switch statement used for processing the commands is clumsy, so I'll work on both of those.




So the immediate plan is
  - replace the switch statement structure with object notation initially in the form 'parentobject[command letter](value)'
  - design and implement  a new layer of command syntax in the tables which is more human friendly and less error prone; "high level commands"

  - first command to implement is exec(<low level command string>); which just executes the toString
  - then implement move(<%destination room>); which generates a low level command string to be executed by the existing low level engine, taking advantage of the room numbering message convention described below, maybe via a template including D?000 or D?001 where ? is substituted with the room number when generating the string. 

  - create a database table for "prototypes".
 -






- Convention for room description message numbering;
  - room numbers map to message numbers by adding 3 zeros to the end, so room 1 maps to message 1000, 1001 etc
  - x000 will always be the detailed room description, x001 will be the short descriptions
  - x100 will be the start of the numbering range for 'non-standard' messages.
