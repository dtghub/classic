Currently a separate document from the main plan and ideas document, to help plan and work out the implementation details for the command parser; in particular how to handle the in-game items such as things that the player can pick up and / or interact with.

Types of objects we might need to deal with;

  - Physical items like a lamp, a box of matches etc which can be picked up and dropped and manipulated.
  - Items which are actually properties of a room such as door locks, pictures hanging on walls, (darkness?).
  - Properties which are partially or completely room independent such as day/night (darkness), hunger and other decrement counters (e.g. the lamp needs filled with oil)?



Ways to interact with objects;

  - know information; examine an item 'examine paper' "This is a ordinary looking piece of notepaper. It has a note scribbled on it in blue ink" (also display information e.g. 'read note' or do we make note a synonym which gets tokenised to 'Npaper'?).
  - take action; set a property flag (e.g. lamp is lit - or do we just swap a lamp for a lit lamp i.e. they are two different objects?)
  - move item; set the location of an item (room number, ?room number but invisible?, in your inventory, other special locations such as in a drawer).



  Do we want 'nested' actions - i.e. 1 command causes a series of responses



    - Know info intents - these can be stored under the 'paper' object as a {key: value} pair in the form {examine: K10} K10 causes message number 10 from the 'K' list to be displayed.

    - move item intents - these can be in the form of location changes e.g. 'L15' moves the item to Location 15
        - need to be able to identify the  object being moved - so 'I10' might be the lamp and 'I11' is the lit lamp - syntax might be in the form 'I10L15' = move lamp to location 15, maybe include a separator character to help with command parsing. Light lamp command could move lamp to location 9999 and move lit lamp to location 0 (where 0 is your inventory)
        - might want to be able to require that you have a box of matches - and have a way of decrementing the number left (swapping items) - to implement this we could have conditionals e.g. {?I23L0?I23L9999?I22L0?} meaning if box with 3 matches in inventory (L0) then move I23 out and put I22 (box with 2 matches) in inventory. Also can use conditional for something as simple as if the item is in your inventory then
        - need to be able to access the properties of an object - syntax maybe %I15%location% returns the location of I15 - I0 represents the player, so that %I0%location% represents the location of the player!
          -in a wider sense, commands that don't (directly) affect items could also use this syntax - it actually follows that they should do for consistency - so the processing of a verb like 'look' with no noun should be implemented as an action attached to the room.
            - a consequence of this is that we no longer need movement verbs as a special case.
          - another consequence is that I now need to implement (at least) 2 more database tables one for messages to display, and another as a repository of commands/command chains that can be called
          - need to reimplement the initialisation routine so that it pulls all of these databases in via one JSON
          - 'blank' values need to have a default response - populate the blank values for the initial early stage, but implement some form of prototype inheritance


    - So now we need a 'protype' database table(s) which has a set of default commands for each inventory
      - maybe allow different items to inherit from other than the default.




So the immediate plan is
  -1st early version of command interpreter to simply implement get and drop as an initial skeleton (initially drop will return the item to its original location)
  - create yet more database tables for prototypes, messages, and functions
  - reimplement the initialisation to import all of the initial tables using one big JSON rather than several unnecessary callbacks

  - loads of other t6hings to add to the above list
